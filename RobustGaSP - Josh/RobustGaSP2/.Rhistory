p_i = n_i/N
mu_i = mean(tempFB$willFrnd)
f = f + p_i*(mu_i - mu)^2/MSE
}
(f = sqrt(f))
pwr.anova.test(k = k, f = f, power = 0.9)
library(lme4)
library(lmerTest)
library(multcomp)
library(lsmeans)
xblock <- read.csv(file="woodconc.csv", header=TRUE)
xblock$woodconc = as.factor(xblock$woodconc)
model = lmer(strength ~ (1|Day) + woodconc, data=xblock)
rand(model) #to test random effect of day
summary(model) #shows the significance of woodconc
anova(model) #summarizes as an ANOVA
post.hoc <- glht(model, linfct = mcp(woodconc = 'Tukey'))
summary(post.hoc) #Resuly of Tukey's Comparison
(model_ls_means = ls_means(model, which = "woodconc"))
mean(model_ls_means$Estimate)
# testing ls_means
wood_rg = ref.grid(model)
wood_rg
# testing ls_means
(wood_rg = ref.grid(model))
summary(wood_rg)
lsmeans(wood_rg)
lsmeans(wood_rg, "Day")
lsmeans(wood_rg, "woodconc")
(wood_lsm = ls_means(model, which = "woodconc"))
(wood_lsm = lsmeans(model, ~woodconc))
marginal = lsmeans(model, ~woodconc)
marginal = lsmeans(model, ~woodconc)
pairs(marginal, adjust="tukey")
(marginal = lsmeans(model, ~woodconc))
pairs(marginal, adjust="tukey")
mean(marginal$lsmean)
mean(marginal$lsmeans)
(marginal = lsmeans(model, ~woodconc))
pairs(marginal, adjust="tukey")
marginal
marginal$woodconc
mean(c(116,121,131,140,144,123,130))
library(lme4)
library(lmerTest)
library(multcompView)
library(lsmeans)
model = lmer(Score ~ (1|Operator) + Cycle.Time + Temperature + Cycle.Time*Temperature, data=x)
x=read.csv(file="C:/Users/jdseidma/Downloads/Data_Q5.24.csv", header=TRUE)
ls(x)
head(x)
x$Cycle.Time=as.factor(x$Cycle.Time)
x$Temperature=as.factor(x$Temperature)
x$Operator = as.factor(x$Operator)
library(lme4)
library(lmerTest)
library(multcompView)
library(lsmeans)
model = lmer(Score ~ (1|Operator) + Cycle.Time + Temperature + Cycle.Time*Temperature, data=x)
rand(model)
marginal = lsmeans(model, ~Cycle.Time*Temperature)
pairs(marginal, adjust="tukey")
marginal
effect_name = c("A", "AB", "ABC", "B", "AC", "ABD", "C", "AD",
"ACD", "D", "BC", "BCD", "BD", "ABCD", "CD")
effect_size = c(76.95, -51.32, -2.82, -67.52, 11.69, -6.50, -7.84,
9.78, 10.20, -18.73, 20.78, -6.25, 14.74, -6.25, 1.27)
problem_effect = data.frame(effect_name, effect_size)
#Note example.effect[,2] is to use only the calculated effects and not the names.
tmp = qqnorm(problem_effect[,2], main = "Normal Probability Plot", ylab = "Effects", xlab = "Theoretical       Quantiles",datax = TRUE); qqline(problem_effect[,2], datax = TRUE)
#This will use the points pulled from temp and example.effects[,1] to plot the effect names by their respective points.
text(tmp$x, tmp$y, problem_effect[,1], pos = 3, cex = .55)
library(latex2exp)
library(ggplot2)
library(MASS)
library(class)
library(plotly)
library(dplyr)
library(pwr)
library(gridExtra)
library(metRology)
library(broom)
library(lme4)
library(rsm)
tool_est = tool
library(latex2exp)
library(ggplot2)
library(MASS)
library(class)
library(plotly)
library(dplyr)
library(pwr)
library(gridExtra)
library(metRology)
library(broom)
library(lme4)
library(rsm)
A = c(-1,1,-1,1,-1,1,-1,1)
B = c(-1,-1,1,1,-1,-1,1,1)
C = c(-1,-1,-1,-1,1,1,1,1)
AB = A*B
AC = A*C
BC = B*C
ABC = A*B*C
life1 = c(22,32,35,55,44,40,60,39)
life2 = c(31,43,34,47,45,37,50,41)
life3 = c(25,29,50,46,38,36,54,47)
life = c(life1, life2, life3)
k = 3
n = 3
ABC.model = data.frame(A,B,C,AB,AC,BC,ABC)
tool_effect = data.frame("a" = sum(A*life),
"b" = sum(B*life),
"c" = sum(C*life),
"ab" = sum(AB*life),
"ac" = sum(AC*life),
"bc" = sum(BC*life),
"abc" = sum(ABC*life))/(n*2^(k-1))
# tool.coefficients = tool_effects/2
(tool_effect = data.frame(colnames = c(colnames(tool_effect)), c(unlist(unname(tool_effect[1,])))))
#Note example.effect[,2] is to use only the calculated effects and not the names.
tmp = qqnorm(tool_effect[,2], main = "Normal Probability Plot", ylab = "Effects", xlab = "Theoretical Quantiles",datax = TRUE); qqline(tool_effect[,2], datax = TRUE)
#This will use the points pulled from temp and example.effects[,1] to plot the effect names by their respective points.
text(tmp$x, tmp$y, tool_effect[,1], pos = 3, cex = .55)
# Bansal's code
#A function to find the effect given a model, the response, and the number of replications
find.effect = function(model, response, n = 1){
#This will make a data frame with the column names from your model in the first column
#The second column will give you all 0 values
effect.calc = data.frame(colnames(model), rep(0, n=length(model)))
#Here is the formula to determine 2^(k-1)*n
#where 2^(k-1) is simply the number of observations at each level
df = nrow(model)/2*n
print(df)
#This function will give the effects based on the model you put in.
effect.calc[,2] = sapply(1:ncol(model), function(i) sum(model[,i]*response)/df)
return(effect.calc)
#This states that the given value will be returned by the function
}
tool_effect = find.effect(ABC.model, life, n = 3)
tool_effect
#Note example.effect[,2] is to use only the calculated effects and not the names.
tmp = qqnorm(tool_effect[,2], main = "Normal Probability Plot", ylab = "Effects", xlab = "Theoretical       Quantiles",datax = TRUE); qqline(tool_effect[,2], datax = TRUE)
#This will use the points pulled from temp and example.effects[,1] to plot the effect names by their respective points.
text(tmp$x, tmp$y, tool_effect[,1], pos = 3, cex = .55)
tool = data.frame(A,B,C,AB,AC,BC,ABC,life)
tool_aov = aov(life ~ A+B+C+AB+AC+BC+ABC, tool)
summary(tool_aov)
tool_coefficients = tool_effect
tool_coefficients[,2] = tool_coefficients[,2]/2
tool_coefficients = rbind(tool_coefficients,c("Intercept", mean(life)))
tool_coefficients
tool_est = tool
tool_est$fitted = numeric(nrow(tool))
for(i in 1:nrow(tool)){
tool_est[i,9] = sum(as.numeric(tool[i,-c(8)])*as.numeric(tool_coefficients[-c(8),2])) +
as.numeric(tool_coefficients[8,2])
}
tool_est$residuals = tool_est$life - tool_est$fitted
ggplot(tool_est,
aes(sample = residuals)) +
stat_qq() +
stat_qq_line() +
xlab("Theoretical Quantiles") +
ylab("Sample Quantiles")
ggplot(tool_est) +
geom_point(aes(x = fitted, y = residuals))
tool
install.packages("ggplot2")
library(ggplot2)
#3D contour plot example, note while the data is not the best for the example the code methods are fine.
batch = c(1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5)
day = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5)
time = c(8, 11, 4, 6, 4, 7, 2, 9, 8, 2, 1, 7, 10, 6, 3, 7, 3, 3.58, 6, 8, 3, 8, 5, 10, 8)
model = data.frame(batch, day, time)
V = ggplot(data = model, aes(batch, day, z = time))
V + geom_contour()
#Adds more bins
V+geom_contour(bins = 20)
#Makes the colors different for different levels
V+geom_contour(aes(colour = stat(level)))
#Response surface and contour plot for 3 factors
A = (c(-1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1))
B = (c(-1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1))
C = (c(-1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1))
y.var = c(22, 30, 33, 55, 44, 50, 60, 37, 31, 43, 34, 47, 45, 37, 50, 41, 25, 29, 50, 46, 38, 36, 54, 47)
model = data.frame(y.var, A,B,C)
lm.res = lm(y.var~A*B*C)
install.packages("rsm")
library(rsm)
lm.rsm = rsm(y.var~FO(A,B,C)+TWI(A,B,C), data = model)
#Response surfaces?
persp(lm.rsm, ~A+B+C, at = xs(lm.rsm), contours = "col", col = rainbow(40))
#Contour plots
contour(lm.rsm, ~A+B+C, at = xs(lm.rsm), atpos = 0, image = TRUE)
lm.rsm = rsm(life~FO(A,B,C)+TWI(A,B,C), data = tool)
#Response surfaces?
persp(lm.rsm, ~A+B+C, at = xs(lm.rsm), contours = "col", col = rainbow(40))
lm.rsm = rsm(life~FO(A,B,C)+TWI(A,B,C), data = tool)
#Response surfaces?
par(mar = c(1,1,1,1))
persp(lm.rsm, ~A+B+C, at = xs(lm.rsm), contours = "col", col = rainbow(40))
xs(lm.rsm)
#Contour plots
contour(lm.rsm, ~A+B+C, at = xs(lm.rsm), atpos = 0, image = TRUE)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1,)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
ABC.model = data.frame(A,B,C,AB,AC,BC,ABC)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
vibe_effect = find.effect(AB.model, vibe)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
vibe_effect = find.effect(AB.model, vibe, k = k)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
vibe_effect = find.effect(AB.model, vibe, n = n)
vibe_effect
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
(vibe_effect = find.effect(AB.model, vibe, n = n))
AB
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
# Bansal's code
#A function to find the effect given a model, the response, and the number of replications
find.effect = function(model, response, n = 1){
#This will make a data frame with the column names from your model in the first column
#The second column will give you all 0 values
effect.calc = data.frame(colnames(model), rep(0, n=length(model)))
#Here is the formula to determine 2^(k-1)*n
#where 2^(k-1) is simply the number of observations at each level
df = nrow(model)/2*n
#This function will give the effects based on the model you put in.
effect.calc[,2] = sapply(1:ncol(model), function(i) sum(model[,i]*response)/df)
return(effect.calc)
#This states that the given value will be returned by the function
}
tool_effect = find.effect(ABC.model, life, n = 3)
tool_effect
#Note example.effect[,2] is to use only the calculated effects and not the names.
tmp = qqnorm(tool_effect[,2], main = "Normal Probability Plot", ylab = "Effects", xlab = "Theoretical       Quantiles",datax = TRUE); qqline(tool_effect[,2], datax = TRUE)
#This will use the points pulled from temp and example.effects[,1] to plot the effect names by their respective points.
text(tmp$x, tmp$y, tool_effect[,1], pos = 3, cex = .55)
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(life1, life2, life3)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
(vibe_effect = find.effect(AB.model, vibe, n = n))
router = data.frame(A,B,AB,vibe)
router
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(vibe1,vibe2,vibe3,vibe4)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
(vibe_effect = find.effect(AB.model, vibe, n = n))
router = data.frame(A,B,AB,vibe)
router
aov(vibe ~ A + B + AB, router)
router = data.frame(A,B,AB,vibe)
router_aov = aov(vibe ~ A + B + AB, router)
summary(router)
router = data.frame(A,B,AB,vibe)
router_aov = aov(vibe ~ A + B + AB, router)
summary(router_aov)
mean(vibe)
16.6375/2
router_est = router
router_est$fitted = numeric(nrow(router))
for(i in 1:nrow(router)){
router_est[i,9] = sum(as.numeric(router[i,-c(8)])*as.numeric(router_coefficients[-c(8),2])) +
as.numeric(router_coefficients[8,2])
}
router_coefficients = router_effect
A = c(-1,1,-1,1)
B = c(-1,-1,1,1)
AB = A*B
vibe1 = c(18.2,27.2,15.9,41.0)
vibe2 = c(18.9,24.0,14.5,43.9)
vibe3 = c(12.9,22.4,15.1,36.3)
vibe4 = c(14.4,22.5,14.2,39.9)
vibe = c(vibe1,vibe2,vibe3,vibe4)
k = 2
n = 4
AB.model = data.frame(A,B,AB)
(router_effect = find.effect(AB.model, vibe, n = n))
router = data.frame(A,B,AB,vibe)
router_aov = aov(vibe ~ A + B + AB, router)
summary(router_aov)
router_coefficients = router_effect
router_coefficients[,2] = router_coefficients[,2]/2
router_coefficients = rbind(router_coefficients,c("Intercept", mean(life)))
router_coefficients
router_est = router
router_est$fitted = numeric(nrow(router))
for(i in 1:nrow(router)){
router_est[i,9] = sum(as.numeric(router[i,-c(8)])*as.numeric(router_coefficients[-c(8),2])) +
as.numeric(router_coefficients[8,2])
}
router_coefficients = router_effect
router_coefficients[,2] = router_coefficients[,2]/2
router_coefficients = rbind(router_coefficients,c("Intercept", mean(life)))
router_coefficients
router_est = router
router_est$fitted = numeric(nrow(router))
for(i in 1:nrow(router)){
router_est[i,nrow(router_est)] = sum(as.numeric(router[i,-c(ncol(router))])*as.numeric(router_coefficients[-c(8),2])) +
as.numeric(router_coefficients[8,2])
}
router_coefficients = router_effect
router_coefficients[,2] = router_coefficients[,2]/2
router_coefficients = rbind(router_coefficients,c("Intercept", mean(life)))
router_coefficients
router_est = router
router_est$fitted = numeric(nrow(router))
for(i in 1:nrow(router)){
router_est[i,nrow(router_est)] = sum(as.numeric(router[i,-c(ncol(router))])*as.numeric(router_coefficients[-c(nrow(router_coefficients)),2])) +
as.numeric(router_coefficients[nrow(router_coefficients),2])
}
router_coefficients
router_coefficients = router_effect
router_coefficients[,2] = router_coefficients[,2]/2
router_coefficients = rbind(router_coefficients,c("Intercept", mean(vibe)))
router_coefficients
router_est = router
router_est$fitted = numeric(nrow(router))
for(i in 1:nrow(router)){
router_est[i,nrow(router_est)] = sum(as.numeric(router[i,-c(ncol(router))])*as.numeric(router_coefficients[-c(nrow(router_coefficients)),2])) +
as.numeric(router_coefficients[nrow(router_coefficients),2])
}
router_coefficients
router_coefficients = router_effect
router_coefficients[,2] = router_coefficients[,2]/2
router_coefficients = rbind(router_coefficients,c("Intercept", mean(vibe)))
router_coefficients
router_est = router
router_est$fitted = numeric(nrow(router))
for(i in 1:nrow(router)){
router_est[i,ncol(router_est)] = sum(as.numeric(router[i,-c(ncol(router))])*as.numeric(router_coefficients[-c(nrow(router_coefficients)),2])) +
as.numeric(router_coefficients[nrow(router_coefficients),2])
}
router_est$residuals = router_est$life - router_est$fitted
router_est
router_coefficients = router_effect
router_coefficients[,2] = router_coefficients[,2]/2
router_coefficients = rbind(router_coefficients,c("Intercept", mean(vibe)))
router_coefficients
router_est = router
router_est$fitted = numeric(nrow(router))
for(i in 1:nrow(router)){
router_est[i,ncol(router_est)] = sum(as.numeric(router[i,-c(ncol(router))])*as.numeric(router_coefficients[-c(nrow(router_coefficients)),2])) +
as.numeric(router_coefficients[nrow(router_coefficients),2])
}
router_est$residuals = router_est$vibe - router_est$fitted
# profile owner and evaluator
intplot <- function(data, factor1, factor2, y){
factor1 = deparse(substitute(factor1))
factor2 = deparse(substitute(factor2))
y = deparse(substitute(y))
tempdf = mutate(data, response = data[[y]],
f1 = data[[factor1]],
f2 = data[[factor2]]) %>%
group_by(f1, f2) %>%
summarise(meanresponse = mean(response, na.rm = T))
ggplot(tempdf, aes(f1, meanresponse)) +
geom_line(size = 1.2, aes(group = f2, color = f2)) +
geom_point(aes(color = f2), shape = 15) +
labs(x = factor1, color = factor2)
}
intplot(router_est, A, B, vibe)
router_est
router_est[,1:3] = as.factor(router_est[,1:3])
# profile owner and evaluator
intplot <- function(data, factor1, factor2, y){
factor1 = deparse(substitute(factor1))
factor2 = deparse(substitute(factor2))
y = deparse(substitute(y))
tempdf = mutate(data, response = data[[y]],
f1 = data[[factor1]],
f2 = data[[factor2]]) %>%
group_by(f1, f2) %>%
summarise(meanresponse = mean(response, na.rm = T))
ggplot(tempdf, aes(f1, meanresponse)) +
geom_line(size = 1.2, aes(group = f2, color = f2)) +
geom_point(aes(color = f2), shape = 15) +
labs(x = factor1, color = factor2)
}
router_est[c("A","B","AB")] = lapply(router_est[c("A","B","AB")], as.factor)
intplot(router_est, A, B, vibe)
intplot(router_est,B,A)
intplot(router_est,B,A,vibe)
# profile owner and evaluator
intplot <- function(data, factor1, factor2, y){
factor1 = deparse(substitute(factor1))
factor2 = deparse(substitute(factor2))
y = deparse(substitute(y))
tempdf = mutate(data, response = data[[y]],
f1 = data[[factor1]],
f2 = data[[factor2]]) %>%
group_by(f1, f2) %>%
summarise(meanresponse = mean(response, na.rm = T))
ggplot(tempdf, aes(f1, meanresponse)) +
geom_line(size = 1.2, aes(group = f2, color = f2)) +
geom_point(aes(color = f2), shape = 15) +
labs(x = factor1, color = factor2)
}
router_est[c("A","B","AB")] = lapply(router_est[c("A","B","AB")], as.factor)
intplot(router_est, A, B, vibe)
intplot(router_est, B, A, vibe)
install.packages("devtools")
libray(devtools)
library(devtools)
install("C:\Users\jdseidma\Dropbox\Research\Vecchia\VecchiaRobustGaSP_JS\RobustGaSP_0.6.6 - JS\RobustGaSPJS")
install("C:/Users/jdseidma/Dropbox/Research/Vecchia/VecchiaRobustGaSP_JS/RobustGaSP_0.6.6 - JS/RobustGaSPJS")
sessionInfo()
install.packages("https://github.com/cran/RobustGaSP.git")
install.packages("https://github.com/cran/RobustGaSP.git")
library(devtools)
library(devtools)
install.packages('https://github.com/cran/RobustGaSP.git')
install_github("RobustGaSP")
install_github("cran/RobustGaSP")
remove.packages("test")
setwd("C:/Users/jdseidma/Dropbox/Research/SVecchia_RobustGaSP/RobustGaSP - Josh/RobustGaSP2")
devtools::install()
