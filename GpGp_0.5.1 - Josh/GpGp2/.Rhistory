data2
A = as.integer(data2$Apatite)
B = as.integer(data2$pH)
C = as.integer(data2$Pb)
D = as.integer(data2$Diet)
AB = A*B
AC = A*C
AD = A*D
BC = B*C
BD = B*D
CD = C*D
ABC = A*B*C
ABD = A*B*D
ACD = A*C*D
BCD = B*C*D
ABCD = A*B*C*D
ABCD.model = data.frame(A,B,C,D,AB,AC,AD,ABCD)
# First looking at Pb_Response
example_effect = find.effect(ABCD.model, data2$Pb_Response_mM,
n = 1)
conf = nrow(example_effect)
tmp = qqnorm(example_effect[-conf,2], main = "Normal Probability Plot",
ylab = "Effects", xlab = "Theoretical Quantiles",
datax = TRUE); qqline(example_effect[-conf,2], datax = TRUE)
text(tmp$x, tmp$y, example_effect[-conf,1], pos = 3, cex = .55)
data3 = data2
colnames(data3) = c("A","B","C",colnames(data2)[-(1:3)])
fish.aov = lm(Pb_Response_mM ~ A+C, data3)
summary(fish.aov)
data3 = data2
colnames(data3) = c("A","B","C",colnames(data2)[-(1:3)])
fish.aov = lm(Pb_Response_mM ~ (A+B+C+D)^2, data3)
summary(fish.aov)
data3 = data2
colnames(data3) = c("A","B","C",colnames(data2)[-(1:3)])
fish.aov = aov(Pb_Response_mM ~ (A+B+C+D)^2, data3)
summary(fish.aov)
# First looking at pH_Response
example_effect = find.effect(ABCD.model, data2$pH_Response,
n = 1)
conf = nrow(example_effect)
tmp = qqnorm(example_effect[-conf,2], main = "Normal Probability Plot",
ylab = "Effects", xlab = "Theoretical Quantiles",
datax = TRUE); qqline(example_effect[-conf,2], datax = TRUE)
text(tmp$x, tmp$y, example_effect[-conf,1], pos = 3, cex = .55)
fish.aov = aov(ph_Response ~ A+B+C+D+AD, data3)
data3
fish.aov = aov(pH_Response ~ A+B+C+D+AD, data3)
summary(fish.aov)
fish.aov = aov(pH_Response ~ A+B+C+D+AD, data3)
summary(fish.aov)
A = as.integer(data2$Apatite)
B = as.integer(data2$pH)
C = as.integer(data2$Pb)
D = as.integer(data2$Diet)
AB = A*B
AC = A*C
AD = A*D
BC = B*C
BD = B*D
CD = C*D
ABC = A*B*C
ABD = A*B*D
ACD = A*C*D
BCD = B*C*D
ABCD = A*B*C*D
ABCD.model = data.frame(A,B,C,D,AB,AC,AD,ABCD)
# First looking at Pb_Response
example_effect = find.effect(ABCD.model, data2$Pb_Response_mM,
n = 1)
conf = nrow(example_effect)
tmp = qqnorm(example_effect[-conf,2], main = "Normal Probability Plot",
ylab = "Effects", xlab = "Theoretical Quantiles",
datax = TRUE); qqline(example_effect[-conf,2], datax = TRUE)
text(tmp$x, tmp$y, example_effect[-conf,1], pos = 3, cex = .55)
example_effect
setwd("C:/Users/thema/Dropbox/Research/Vecchia/RobustGaSP - Josh/RobustGaSP2")
devtools::install()
setwd("C:/Users/thema/Dropbox/Research/Vecchia/GpGp_0.5.1 - Josh/GpGp2")
devtools::install()
devtools::install()
rm(list = base::ls())
#############################################################
#############################################################
# YOU MIGHT NEED TO REINSTALL THE PACKAGE IF EDITS WERE MADE!
#############################################################
#############################################################
library(GpGp2)
library(GPvecchia)
library(RobustGaSP2)
library(tictoc)
library(plotly)
setwd("C:/Users/thema/Dropbox/Research/Vecchia")
#--------functions defined here----
v_ll = function(rp1, zeromean = "Yes", lik = "notint"){
if(zeromean == "Yes"){
if(lik == "int"){
return(GpGp2::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}else{
return(GpGp::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}
}else if(zeromean == "No"){
if(lik == "int"){
return(GpGp2::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}else{
return(GpGp::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}
}
}
pp_ll = function(rp1, zeromean = "Yes"){
out = c()
out = c(out,
log_marginal_lik_ppgasp(log(c(1/rp1,0)), nugget = 0, nugget_est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, kernel_type = 2, alpha = alpha))
out = c(out, log_approx_ref_prior(log(c(1/rp1,0)),nugget=0,nugget_est=F,CL,a,b))
out = c(out, -neg_log_marginal_post_approx_ref_ppgasp(log(c(1/rp1,1)), nugget = 0, nugget.est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, CL = CL, a=a, b=b,
kernel_type = 2, alpha = alpha))
return(out)
}
# manually computing covariance/correlation matrix
manual_S <- function(rp, method){
fast = F
if(fast){
# fast version only for 1D
d = abs(outer(c(X),c(X),"-"))/rp
if(method == "V"){
S = var(y)^1*(1+sqrt(1)*d)*exp(-sqrt(1)*d)
}else{
S = var(y)^0*(1+sqrt(3)*d)*exp(-sqrt(3)*d)
}
}else{
if(method == "p"){
S = matrix(1,nrow(X),nrow(X))
for(d in 1:length(rp)){
result = sqrt(3)*R0[[d]]/rp[d]
S = S*(1+result)*exp(-result)
}
}else{
Dinv = solve(c(rp)*diag(length(rp)))
R0array = abind::abind(R0, along=3)
S = apply(R0array, MARGIN = c(1,2), FUN = function(x) norm(Dinv%*%x, "2"))
S = (1+S)*exp(-S)
}
}
return(S)
}
#-------------simulate the data----
# simulating a GP
# set.seed(1734458967+122)
# set.seed(1734458967+124)
# set.seed(1734458967+126)
# col1 = matrix(seq(0,3,0.01)) # for n = 301
col1 = seq(0,3,0.1) # for n = 51
sim_X = cbind(col1)
#------comment out for 1D----
col2 = col1 + rnorm(length(col1),0,0.1)
sim_X = cbind(sim_X, col2)
# col3 = col1 + rnorm(length(col1),0,0.1)
# sim_X = cbind(sim_X, col3)
#----------------------------
sim_rp = c(0.5,0.8) # need to change this if going from 1D to 2D vice versa
sim_S_v = matern15_scaledim(c(1,sim_rp,0),sim_X)
sim_L = chol(sim_S_v)
sim_y = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
# sim_y = sim_X + sim_y
inputs = sim_X
zeromean = "No"
if(zeromean == "Yes"){
y = sim_y - mean(sim_y)
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
nuggie = 0.7/as.numeric(var(y))
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
toc()
(exact_rp = 1/test_pp@beta_hat)
(vecchia_rp = 1/test_v@beta_hat)
all.equal(c(exact_rp,test_pp@nugget), c(vecchia_rp,test_v@nugget))
rm(list = base::ls())
#############################################################
#############################################################
# YOU MIGHT NEED TO REINSTALL THE PACKAGE IF EDITS WERE MADE!
#############################################################
#############################################################
library(GpGp2)
library(GPvecchia)
library(RobustGaSP2)
library(tictoc)
library(plotly)
setwd("C:/Users/thema/Dropbox/Research/Vecchia")
#--------functions defined here----
v_ll = function(rp1, zeromean = "Yes", lik = "notint"){
if(zeromean == "Yes"){
if(lik == "int"){
return(GpGp2::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}else{
return(GpGp::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}
}else if(zeromean == "No"){
if(lik == "int"){
return(GpGp2::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}else{
return(GpGp::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}
}
}
pp_ll = function(rp1, zeromean = "Yes"){
out = c()
out = c(out,
log_marginal_lik_ppgasp(log(c(1/rp1,0)), nugget = 0, nugget_est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, kernel_type = 2, alpha = alpha))
out = c(out, log_approx_ref_prior(log(c(1/rp1,0)),nugget=0,nugget_est=F,CL,a,b))
out = c(out, -neg_log_marginal_post_approx_ref_ppgasp(log(c(1/rp1,1)), nugget = 0, nugget.est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, CL = CL, a=a, b=b,
kernel_type = 2, alpha = alpha))
return(out)
}
# manually computing covariance/correlation matrix
manual_S <- function(rp, method){
fast = F
if(fast){
# fast version only for 1D
d = abs(outer(c(X),c(X),"-"))/rp
if(method == "V"){
S = var(y)^1*(1+sqrt(1)*d)*exp(-sqrt(1)*d)
}else{
S = var(y)^0*(1+sqrt(3)*d)*exp(-sqrt(3)*d)
}
}else{
if(method == "p"){
S = matrix(1,nrow(X),nrow(X))
for(d in 1:length(rp)){
result = sqrt(3)*R0[[d]]/rp[d]
S = S*(1+result)*exp(-result)
}
}else{
Dinv = solve(c(rp)*diag(length(rp)))
R0array = abind::abind(R0, along=3)
S = apply(R0array, MARGIN = c(1,2), FUN = function(x) norm(Dinv%*%x, "2"))
S = (1+S)*exp(-S)
}
}
return(S)
}
#-------------simulate the data----
# simulating a GP
# set.seed(1734458967+122)
# set.seed(1734458967+124)
# set.seed(1734458967+126)
# col1 = matrix(seq(0,3,0.01)) # for n = 301
col1 = seq(0,3,0.1) # for n = 51
sim_X = cbind(col1)
#------comment out for 1D----
col2 = col1 + rnorm(length(col1),0,0.1)
sim_X = cbind(sim_X, col2)
# col3 = col1 + rnorm(length(col1),0,0.1)
# sim_X = cbind(sim_X, col3)
#----------------------------
sim_rp = c(0.5,0.8) # need to change this if going from 1D to 2D vice versa
sim_S_v = matern15_scaledim(c(1,sim_rp,0),sim_X)
sim_L = chol(sim_S_v)
sim_y = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
# sim_y = sim_X + sim_y
inputs = sim_X
zeromean = "No"
if(zeromean == "Yes"){
y = sim_y - mean(sim_y)
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
nuggie = 0.7/as.numeric(var(y))
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
toc()
(exact_rp = 1/test_pp@beta_hat)
(vecchia_rp = 1/test_v@beta_hat)
all.equal(c(exact_rp,test_pp@nugget), c(vecchia_rp,test_v@nugget))
setwd("C:/Users/thema/Dropbox/Research/Vecchia/GpGp_0.5.1 - Josh/GpGp2")
devtools::install()
rm(list = base::ls())
#############################################################
#############################################################
# YOU MIGHT NEED TO REINSTALL THE PACKAGE IF EDITS WERE MADE!
#############################################################
#############################################################
library(GpGp2)
library(GPvecchia)
library(RobustGaSP2)
library(tictoc)
library(plotly)
setwd("C:/Users/thema/Dropbox/Research/Vecchia")
#--------functions defined here----
v_ll = function(rp1, zeromean = "Yes", lik = "notint"){
if(zeromean == "Yes"){
if(lik == "int"){
return(GpGp2::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}else{
return(GpGp::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}
}else if(zeromean == "No"){
if(lik == "int"){
return(GpGp2::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}else{
return(GpGp::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}
}
}
pp_ll = function(rp1, zeromean = "Yes"){
out = c()
out = c(out,
log_marginal_lik_ppgasp(log(c(1/rp1,0)), nugget = 0, nugget_est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, kernel_type = 2, alpha = alpha))
out = c(out, log_approx_ref_prior(log(c(1/rp1,0)),nugget=0,nugget_est=F,CL,a,b))
out = c(out, -neg_log_marginal_post_approx_ref_ppgasp(log(c(1/rp1,1)), nugget = 0, nugget.est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, CL = CL, a=a, b=b,
kernel_type = 2, alpha = alpha))
return(out)
}
# manually computing covariance/correlation matrix
manual_S <- function(rp, method){
fast = F
if(fast){
# fast version only for 1D
d = abs(outer(c(X),c(X),"-"))/rp
if(method == "V"){
S = var(y)^1*(1+sqrt(1)*d)*exp(-sqrt(1)*d)
}else{
S = var(y)^0*(1+sqrt(3)*d)*exp(-sqrt(3)*d)
}
}else{
if(method == "p"){
S = matrix(1,nrow(X),nrow(X))
for(d in 1:length(rp)){
result = sqrt(3)*R0[[d]]/rp[d]
S = S*(1+result)*exp(-result)
}
}else{
Dinv = solve(c(rp)*diag(length(rp)))
R0array = abind::abind(R0, along=3)
S = apply(R0array, MARGIN = c(1,2), FUN = function(x) norm(Dinv%*%x, "2"))
S = (1+S)*exp(-S)
}
}
return(S)
}
#-------------simulate the data----
# simulating a GP
# set.seed(1734458967+122)
# set.seed(1734458967+124)
# set.seed(1734458967+126)
# col1 = matrix(seq(0,3,0.01)) # for n = 301
col1 = seq(0,3,0.1) # for n = 51
sim_X = cbind(col1)
#------comment out for 1D----
col2 = col1 + rnorm(length(col1),0,0.1)
sim_X = cbind(sim_X, col2)
# col3 = col1 + rnorm(length(col1),0,0.1)
# sim_X = cbind(sim_X, col3)
#----------------------------
sim_rp = c(0.5,0.8) # need to change this if going from 1D to 2D vice versa
sim_S_v = matern15_scaledim(c(1,sim_rp,0),sim_X)
sim_L = chol(sim_S_v)
sim_y = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
# sim_y = sim_X + sim_y
inputs = sim_X
zeromean = "No"
if(zeromean == "Yes"){
y = sim_y - mean(sim_y)
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
nuggie = 0.7/as.numeric(var(y))
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
toc()
(exact_rp = 1/test_pp@beta_hat)
(vecchia_rp = 1/test_v@beta_hat)
all.equal(c(exact_rp,test_pp@nugget), c(vecchia_rp,test_v@nugget))
zeromean = "Yes"
if(zeromean == "Yes"){
y = sim_y - mean(sim_y)
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
nuggie = 0.7/as.numeric(var(y))
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
GpGp2::vecchia_meanzero_loglik(c(var(y),exact_rp,0.5/var(y)),"matern15_scaledim",y,test_locs,test_NNarray)$loglik
log_marginal_lik_ppgasp(log(c(1/exact_rp,0.5/var(y))),0.5/var(y),T,R0,X,zeromean,y,c(2,2),alpha)
CL = test_pp@CL
R0 = test_pp@R0
myX = test_pp@X
GpGp2::vecchia_meanzero_loglik(c(var(y),exact_rp,0.5/var(y)),"matern15_scaledim",y,test_locs,test_NNarray)$loglik
log_marginal_lik_ppgasp(log(c(1/exact_rp,0.5/var(y))),0.5/var(y),T,R0,X,zeromean,y,c(2,2),alpha)
neg_log_marginal_post_approx_ref_deriv_ppgasp(log(c(1/exact_rp,0.5/var(y))),0.5/var(y),T,test_pp@R0,test_pp@X,
zeromean,y,test_pp@CL,a,b,c(2,2),
alpha,vecchia=F,locs=test_locs,NNarray=test_NNarray)
neg_log_marginal_post_approx_ref_deriv_ppgasp(log(c(1/exact_rp,0.5/var(y))),0.5/var(y),T,test_pp@R0,test_pp@X,
zeromean,y,test_pp@CL,a,b,c(2,2),
alpha,vecchia=T,locs=test_locs,NNarray=test_NNarray)
setwd("C:/Users/thema/Dropbox/Research/Vecchia/GpGp_0.5.1 - Josh/GpGp2")
Rcpp::compileAttributes()
devtools::install()
Rcpp::compileAttributes()
devtools::install()
devtools::install()
