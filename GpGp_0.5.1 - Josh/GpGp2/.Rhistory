return(GpGp::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}
}
}
pp_ll = function(rp1, zeromean = "Yes"){
out = c()
out = c(out,
log_marginal_lik_ppgasp(log(c(1/rp1,0)), nugget = 0, nugget_est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, kernel_type = 2, alpha = alpha))
out = c(out, log_approx_ref_prior(log(c(1/rp1,0)),nugget=0,nugget_est=F,CL,a,b))
out = c(out, -neg_log_marginal_post_approx_ref_ppgasp(log(c(1/rp1,1)), nugget = 0, nugget.est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, CL = CL, a=a, b=b,
kernel_type = 2, alpha = alpha))
return(out)
}
# manually computing covariance/correlation matrix
manual_S <- function(rp, method){
fast = F
if(fast){
# fast version only for 1D
d = abs(outer(c(X),c(X),"-"))/rp
if(method == "V"){
S = var(y)^1*(1+sqrt(1)*d)*exp(-sqrt(1)*d)
}else{
S = var(y)^0*(1+sqrt(3)*d)*exp(-sqrt(3)*d)
}
}else{
if(method == "p"){
S = matrix(1,nrow(X),nrow(X))
for(d in 1:length(rp)){
result = sqrt(3)*R0[[d]]/rp[d]
S = S*(1+result)*exp(-result)
}
}else{
Dinv = solve(c(rp)*diag(length(rp)))
R0array = abind::abind(R0, along=3)
S = apply(R0array, MARGIN = c(1,2), FUN = function(x) norm(Dinv%*%x, "2"))
S = (1+S)*exp(-S)
}
}
return(S)
}
#-------------simulate the data----
# simulating a GP
# set.seed(1734458967+122)
# set.seed(1734458967+124)
# set.seed(1734458967+126)
# col1 = matrix(seq(0,3,0.01)) # for n = 301
col1 = seq(0,3,0.1) # for n = 51
sim_X = cbind(col1)
#------comment out for 1D----
col2 = col1 + rnorm(length(col1),0,0.1)
sim_X = cbind(sim_X, col2)
# col3 = col1 + rnorm(length(col1),0,0.1)
# sim_X = cbind(sim_X, col3)
#----------------------------
sim_rp = c(0.5,0.8) # need to change this if going from 1D to 2D vice versa
sim_S_v = matern15_scaledim(c(1,sim_rp,0),sim_X)
sim_L = chol(sim_S_v)
sim_y = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y2 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y3 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y = cbind(sim_y, sim_y2, sim_y3)
inputs = sim_X
zeromean = "Yes"
if(zeromean == "Yes"){
y = apply(sim_y,2,function(x){x - mean(x)})
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
# nuggie = 0.7/as.numeric(var(y))[1]
nuggie = 1
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
(exact_rp = 1/test_pp@beta_hat)
CL = test_pp@CL
R0 = test_pp@R0
myX = test_pp@X
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
toc()
(exact_rp = 1/test_pp@beta_hat)
(vecchia_rp = 1/test_v@beta_hat)
all.equal(c(exact_rp,test_pp@nugget), c(vecchia_rp,test_v@nugget))
neg_log_marginal_post_approx_ref_ppgasp(log(c(1/exact_rp,0.5/var(y)[1])),0.5/var(y)[1],nugget.est = T,test_pp@R0,test_pp@X,
zeromean,y,test_pp@CL,a,b,c(2,2),
alpha,vecchia=T,locs=test_locs,NNarray=test_NNarray)
setwd("C:/Users/jdseidma/Dropbox/Research/SVecchia_RobustGaSP/GpGp_0.5.1 - Josh/GpGp2")
devtools::install()
rm(list = base::ls())
#############################################################
#############################################################
# YOU MIGHT NEED TO REINSTALL THE PACKAGE IF EDITS WERE MADE!
#############################################################
#############################################################
library(GpGp2)
library(GPvecchia)
library(RobustGaSP2)
library(tictoc)
library(plotly)
setwd("C:/Users/jdseidma/Dropbox/Research/Vecchia")
#--------functions defined here----
v_ll = function(rp1, zeromean = "Yes", lik = "notint"){
if(zeromean == "Yes"){
if(lik == "int"){
return(GpGp2::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}else{
return(GpGp::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}
}else if(zeromean == "No"){
if(lik == "int"){
return(GpGp2::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}else{
return(GpGp::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}
}
}
pp_ll = function(rp1, zeromean = "Yes"){
out = c()
out = c(out,
log_marginal_lik_ppgasp(log(c(1/rp1,0)), nugget = 0, nugget_est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, kernel_type = 2, alpha = alpha))
out = c(out, log_approx_ref_prior(log(c(1/rp1,0)),nugget=0,nugget_est=F,CL,a,b))
out = c(out, -neg_log_marginal_post_approx_ref_ppgasp(log(c(1/rp1,1)), nugget = 0, nugget.est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, CL = CL, a=a, b=b,
kernel_type = 2, alpha = alpha))
return(out)
}
# manually computing covariance/correlation matrix
manual_S <- function(rp, method){
fast = F
if(fast){
# fast version only for 1D
d = abs(outer(c(X),c(X),"-"))/rp
if(method == "V"){
S = var(y)^1*(1+sqrt(1)*d)*exp(-sqrt(1)*d)
}else{
S = var(y)^0*(1+sqrt(3)*d)*exp(-sqrt(3)*d)
}
}else{
if(method == "p"){
S = matrix(1,nrow(X),nrow(X))
for(d in 1:length(rp)){
result = sqrt(3)*R0[[d]]/rp[d]
S = S*(1+result)*exp(-result)
}
}else{
Dinv = solve(c(rp)*diag(length(rp)))
R0array = abind::abind(R0, along=3)
S = apply(R0array, MARGIN = c(1,2), FUN = function(x) norm(Dinv%*%x, "2"))
S = (1+S)*exp(-S)
}
}
return(S)
}
#-------------simulate the data----
# simulating a GP
# set.seed(1734458967+122)
# set.seed(1734458967+124)
# set.seed(1734458967+126)
# col1 = matrix(seq(0,3,0.01)) # for n = 301
col1 = seq(0,3,0.1) # for n = 51
sim_X = cbind(col1)
#------comment out for 1D----
col2 = col1 + rnorm(length(col1),0,0.1)
sim_X = cbind(sim_X, col2)
# col3 = col1 + rnorm(length(col1),0,0.1)
# sim_X = cbind(sim_X, col3)
#----------------------------
sim_rp = c(0.5,0.8) # need to change this if going from 1D to 2D vice versa
sim_S_v = matern15_scaledim(c(1,sim_rp,0),sim_X)
sim_L = chol(sim_S_v)
sim_y = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y2 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y3 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y = cbind(sim_y, sim_y2, sim_y3)
inputs = sim_X
zeromean = "Yes"
if(zeromean == "Yes"){
y = apply(sim_y,2,function(x){x - mean(x)})
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
# nuggie = 0.7/as.numeric(var(y))[1]
nuggie = 1
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
(exact_rp = 1/test_pp@beta_hat)
CL = test_pp@CL
R0 = test_pp@R0
myX = test_pp@X
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
toc()
(exact_rp = 1/test_pp@beta_hat)
(vecchia_rp = 1/test_v@beta_hat)
all.equal(c(exact_rp,test_pp@nugget), c(vecchia_rp,test_v@nugget))
rm(list = base::ls())
#############################################################
#############################################################
# YOU MIGHT NEED TO REINSTALL THE PACKAGE IF EDITS WERE MADE!
#############################################################
#############################################################
library(GpGp2)
library(GPvecchia)
library(RobustGaSP2)
library(tictoc)
library(plotly)
setwd("C:/Users/jdseidma/Dropbox/Research/Vecchia")
#--------functions defined here----
v_ll = function(rp1, zeromean = "Yes", lik = "notint"){
if(zeromean == "Yes"){
if(lik == "int"){
return(GpGp2::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}else{
return(GpGp::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}
}else if(zeromean == "No"){
if(lik == "int"){
return(GpGp2::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}else{
return(GpGp::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}
}
}
pp_ll = function(rp1, zeromean = "Yes"){
out = c()
out = c(out,
log_marginal_lik_ppgasp(log(c(1/rp1,0)), nugget = 0, nugget_est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, kernel_type = 2, alpha = alpha))
out = c(out, log_approx_ref_prior(log(c(1/rp1,0)),nugget=0,nugget_est=F,CL,a,b))
out = c(out, -neg_log_marginal_post_approx_ref_ppgasp(log(c(1/rp1,1)), nugget = 0, nugget.est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, CL = CL, a=a, b=b,
kernel_type = 2, alpha = alpha))
return(out)
}
# manually computing covariance/correlation matrix
manual_S <- function(rp, method){
fast = F
if(fast){
# fast version only for 1D
d = abs(outer(c(X),c(X),"-"))/rp
if(method == "V"){
S = var(y)^1*(1+sqrt(1)*d)*exp(-sqrt(1)*d)
}else{
S = var(y)^0*(1+sqrt(3)*d)*exp(-sqrt(3)*d)
}
}else{
if(method == "p"){
S = matrix(1,nrow(X),nrow(X))
for(d in 1:length(rp)){
result = sqrt(3)*R0[[d]]/rp[d]
S = S*(1+result)*exp(-result)
}
}else{
Dinv = solve(c(rp)*diag(length(rp)))
R0array = abind::abind(R0, along=3)
S = apply(R0array, MARGIN = c(1,2), FUN = function(x) norm(Dinv%*%x, "2"))
S = (1+S)*exp(-S)
}
}
return(S)
}
#-------------simulate the data----
# simulating a GP
# set.seed(1734458967+122)
# set.seed(1734458967+124)
# set.seed(1734458967+126)
# col1 = matrix(seq(0,3,0.01)) # for n = 301
col1 = seq(0,3,0.1) # for n = 51
sim_X = cbind(col1)
#------comment out for 1D----
col2 = col1 + rnorm(length(col1),0,0.1)
sim_X = cbind(sim_X, col2)
# col3 = col1 + rnorm(length(col1),0,0.1)
# sim_X = cbind(sim_X, col3)
#----------------------------
sim_rp = c(0.5,0.8) # need to change this if going from 1D to 2D vice versa
sim_S_v = matern15_scaledim(c(1,sim_rp,0),sim_X)
sim_L = chol(sim_S_v)
sim_y = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y2 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y3 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y = cbind(sim_y, sim_y2, sim_y3)
inputs = sim_X
zeromean = "Yes"
if(zeromean == "Yes"){
y = apply(sim_y,2,function(x){x - mean(x)})
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
# nuggie = 0.7/as.numeric(var(y))[1]
nuggie = 1
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
(exact_rp = 1/test_pp@beta_hat)
CL = test_pp@CL
R0 = test_pp@R0
myX = test_pp@X
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
toc()
(exact_rp = 1/test_pp@beta_hat)
(vecchia_rp = 1/test_v@beta_hat)
all.equal(c(exact_rp,test_pp@nugget), c(vecchia_rp,test_v@nugget))
rm(list = base::ls())
#############################################################
#############################################################
# YOU MIGHT NEED TO REINSTALL THE PACKAGE IF EDITS WERE MADE!
#############################################################
#############################################################
library(GpGp2)
library(GPvecchia)
library(RobustGaSP2)
library(tictoc)
library(plotly)
setwd("C:/Users/jdseidma/Dropbox/Research/Vecchia")
#--------functions defined here----
v_ll = function(rp1, zeromean = "Yes", lik = "notint"){
if(zeromean == "Yes"){
if(lik == "int"){
return(GpGp2::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}else{
return(GpGp::vecchia_meanzero_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, X, test_NNarray))
}
}else if(zeromean == "No"){
if(lik == "int"){
return(GpGp2::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}else{
return(GpGp::vecchia_profbeta_loglik(c(var(y), rp1, 0), "matern15_scaledim", y, cbind(matrix(1,nrow(X),1),X), X, test_NNarray))
}
}
}
pp_ll = function(rp1, zeromean = "Yes"){
out = c()
out = c(out,
log_marginal_lik_ppgasp(log(c(1/rp1,0)), nugget = 0, nugget_est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, kernel_type = 2, alpha = alpha))
out = c(out, log_approx_ref_prior(log(c(1/rp1,0)),nugget=0,nugget_est=F,CL,a,b))
out = c(out, -neg_log_marginal_post_approx_ref_ppgasp(log(c(1/rp1,1)), nugget = 0, nugget.est = F, R0 = test_pp@R0,
X = test_pp@X, zero_mean = zeromean, output = y, CL = CL, a=a, b=b,
kernel_type = 2, alpha = alpha))
return(out)
}
# manually computing covariance/correlation matrix
manual_S <- function(rp, method){
fast = F
if(fast){
# fast version only for 1D
d = abs(outer(c(X),c(X),"-"))/rp
if(method == "V"){
S = var(y)^1*(1+sqrt(1)*d)*exp(-sqrt(1)*d)
}else{
S = var(y)^0*(1+sqrt(3)*d)*exp(-sqrt(3)*d)
}
}else{
if(method == "p"){
S = matrix(1,nrow(X),nrow(X))
for(d in 1:length(rp)){
result = sqrt(3)*R0[[d]]/rp[d]
S = S*(1+result)*exp(-result)
}
}else{
Dinv = solve(c(rp)*diag(length(rp)))
R0array = abind::abind(R0, along=3)
S = apply(R0array, MARGIN = c(1,2), FUN = function(x) norm(Dinv%*%x, "2"))
S = (1+S)*exp(-S)
}
}
return(S)
}
#-------------simulate the data----
# simulating a GP
# set.seed(1734458967+122)
# set.seed(1734458967+124)
# set.seed(1734458967+126)
# col1 = matrix(seq(0,3,0.01)) # for n = 301
col1 = seq(0,3,0.1) # for n = 51
sim_X = cbind(col1)
#------comment out for 1D----
col2 = col1 + rnorm(length(col1),0,0.1)
sim_X = cbind(sim_X, col2)
# col3 = col1 + rnorm(length(col1),0,0.1)
# sim_X = cbind(sim_X, col3)
#----------------------------
sim_rp = c(0.5,0.8) # need to change this if going from 1D to 2D vice versa
sim_S_v = matern15_scaledim(c(1,sim_rp,0),sim_X)
sim_L = chol(sim_S_v)
sim_y = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y2 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y3 = t(sim_L)%*%matrix(rnorm(nrow(sim_X)))
sim_y = cbind(sim_y, sim_y2, sim_y3)
inputs = sim_X
zeromean = "Yes"
if(zeromean == "Yes"){
y = apply(sim_y,2,function(x){x - mean(x)})
}else{
y = sim_y
}
test_locs = inputs
ord = order_maxmin(test_locs)
test_locsord = test_locs[ord,]
m = nrow(test_locs)
n = m
m = n
test_NNarray = find_ordered_nn(test_locsord, m)
X = inputs
trend = cbind(matrix(1,nrow = nrow(X),ncol = 1), X)
# trend = matrix(1,nrow = nrow(X),ncol = 1)
alpha = rep(2,dim(as.matrix(X))[2])
test_covfun_name = "matern15_scaledim"
# define prior parameters
a=0.2
b=1/(length(y))^{1/dim(as.matrix(X))[2]}*(a+dim(as.matrix(X))[2])
nest = T
if(nest){
nuggie = 0
}else{
# nuggie = 0.7/as.numeric(var(y))[1]
nuggie = 1
}
tic()
test_pp = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
nugget.est = nest, zero.mean = zeromean)
toc()
(exact_rp = 1/test_pp@beta_hat)
CL = test_pp@CL
R0 = test_pp@R0
myX = test_pp@X
tic()
test_v = ppgasp(X,y,trend = trend, kernel_type = 'matern_3_2', nugget = nuggie,
zero.mean = zeromean, nugget.est = nest,
vecchia = T, locs = test_locs, NNarray = test_NNarray)
toc()
(exact_rp = 1/test_pp@beta_hat)
(vecchia_rp = 1/test_v@beta_hat)
all.equal(c(exact_rp,test_pp@nugget), c(vecchia_rp,test_v@nugget))
y
setwd("C:/Users/jdseidma/Dropbox/Research/SVecchia_RobustGaSP/GpGp_0.5.1 - Josh/GpGp2")
devtools::install()
